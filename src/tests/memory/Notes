Resourced memory test
=====================
Tests the memory module of resourced. The following tests are offered:
* Proactive oom killer: Tests the proactive oom killer called by the prelaunch dbus signal handler
* OOM trigger: Tests the OOM trigger dbus signal handler
* Memory pressure handler (normal): Tests the memory pressure eventfd interface of resourced (without callback)
* Memory pressure handler (callback): Tests the memory pressure eventfd interface of resourced (with callback)

Usage
=====
This test tool can be used as follows:
<cmd-prompt>$ resourced_memory_test <test-name>
	Supported test names are: proactive, oom_trigger and vmpressure

* Executing this tool in the above way results in logging happening in journalctl.
* The tool is interactive and gives instructions on what to do.
* To use different tests consecutively, it is preferred to kill the processes started in the previous test.
  This is preferred as it becomes difficult to create the base usage scenario of the next test with less available memory.
  This can be done by executing the following command.
	<cmd-prompt>$ killall resourced_memory_test
* Along with this tool, the user can run journalctl to see the logs of the test tool.
  The memory test provides its PID to enable following only this process in journalctl as follows:
	$ journalctl -f _PID=<pid-of-memory-test>
* Also, to see the working of the resourced in response to the actions of the test tool, the user can run dlog in 2 ways:
	$ dlogutil RESOURCED -v time			(to see all the logs in resourced)
	$ dlogutil RESOURCED -v time | grep mem		(to see only memory module logs in resourced)

Internal working
================
The basis of all memory tests are going to be the same.
* First create a base usage scenario (i.e. create processes in different cgroups according
  to the test) so as to prep the target to trigger the needed interface in resourced
* Next run the test function corresponding to the input test.
  This test function triggers the interface in resourced and then checks for working of the
  trigger interface by checking for kills in the cgroups according to the conditions of the test
* Depending on the success of the checks, the test success status is determined.

Tests details
=============
* Proactive oom killer: Tests the proactive oom killer called by the prelaunch dbus signal handler
	# The proactive oom killer is called before launching new apps.
	# The purpose of this killer is to check if enough memory is available before launching a new app
	# We trigger this killer by calling the prelaunch signal handler using the dbus sender script
		(see the script on details of how to use the Prelaunch_OOM option)
	# The proactive oom killer kills from the swap and background cgroups only until the available memory
	  reaches proactive threshold leave. It does not kill processes with negative oom and also kills only
	  num_max_victims # of processes (this value is set by the memory.conf file in resourced).
	# We create processes throughout all the cgroups with more processes in the memory and background cgroup.
	# Some of these processes are with -ve oom and some are with +ve oom.
	# After sending the dbus signal, the test function checks if the correct processes are killed/not killed.

* OOM trigger: Tests the OOM trigger dbus signal handler
	# OOM trigger function is called when resourced receives the respective dbus signal
	# The purpose of this killer is to clear all possible memory in swap and background cgroup
	  upon receiving the dbus oom signal
	# We trigger this interface by calling the oom trigger handler using the dbus sender script
		(see the script for details on how to use the OOM_Trigger option)
	# The oom trigger killer kills from the swap and background cgroup without any restrictions on
	  recovery target or the number of kills. Only processes with -ve oom are not killed.
	# We create processes throughout all the cgroups with more processes in the memory and background cgroup.
	# Some of the processes are with -ve oom, but most are with +ve oom.
	# After sending the dbus signal, the test function checks if the processes in the cgroup are correctly killed/not killed.

* Memory pressure handler (normal): Tests the memory pressure eventfd interface of resourced (without callback)
	# This interface is activated when the usage of the root memcg exceeds the medium pressure level
	# The purpose of this killer is to free enough memory after the pressure level exceeds medium
	# We trigger this interface by using more than medium threshold of memory when creating the base usage scenario
	# Kernel notifies resourced of the crossing of the medium pressure level and the interface gets activated.
	# We wait for some time before the interface is activated and then check for kills.
	# This killer kills processes in each cgroup starting from the swap cgroup proceeding till the root cgroup.
	# This killing continues until the available memory reaches threshold leave of the memory configuration/max victims
	  are killed in a cgroup.
	# We create processes throughout all the cgroups with more processes in the background and foreground cgroups
	# Most of these processes have +ve oom scores (to ensure that enough memory is freed in a single iteration of the killer)
	# After waiting for activation of the interface, we check if processes were killed correctly.

* Memory pressure handler (callback): Tests the memory pressure eventfd interface of resourced (with callback)
	# This interface is a follow up killer called if the first run of the mempressure killer does not free enough memory
	# We trigger this killer in the same way as mentioned in the normal test above
	# Since we dont want the first run of the killer to free enough memory, most processes created in this test
	  have -ve oom. This results in the first run of the vmpressure killer not killing them and calling the callback.
	# We then change the oom of the processes to a +ve value just in time for the callback to kill them and
	  thus allowing us to check for the correctness of the callback killer.
	# We accomplish this by making the user of the test to let us know as soon as the first run of the oom killer thread
	  starts. They can see this by tracking the dlog of resourced memory module.
	# Once they signal this, we check if the processes were killed by the first run. And then we change the oom before
	  the callback is called and check after the finish of the callback if the processes were killed correctly.
	# ** To make this test work correctly, we need to change the OOM_TIMER_INTERVAL constant in vmpressure module to
	  around 15. This is because, it takes some time for the user to notify the test and if the callback is called
	  by this time, we cannot change the oom scores in time to test the working of the callback.
